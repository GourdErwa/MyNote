##缓存

索引有不同的内置缓存模块。 它们包括 过滤器（filter）, 字段（field） 和其它。



##过滤器缓存

过滤器缓存负责缓存过滤后的结果(在查询中使用)。 默认实现过滤器缓存(和一个推荐使用在几乎所有的情况下) 的是 节点过滤器缓存 类型。



##节点过滤器缓存

这个 节点过滤器缓存 可以被配置为使用总内存的一定比例分配给进程或一个指定数量的内存。
所有的索引分片只能出现在一个节点共享一个单一的节点缓存(这就是为什么它叫 节点 ”)。
这个缓存工具实现了一个叫做 LRU 数据删除策略:当缓存区满了以后, 最近最少使用的数据被删除，以腾出空间给新的数据存放。

这个设置允许控制过滤器缓存占多少内存大小， indices.cache.filter.size, 该属性的默认值 20% 。
注意, 这是不一个索引级别的设置，而是节点级别设置(可以在节点上进行配置)。indices.cache.filter.size  可以接受一个百分比值, 如：30%, 或一个精确值, 如：512 mb 。



##索引过滤器缓存

该过滤器缓存是在索引等级上面的(每一个节点上)。 一般来说,不建议使用该缓存，因为缓存内存使用量取决于每个节点上面的分片，这个很难难预测。
这个类型分为: 常驻,  软件 和 弱 （resident, soft and weak.）。

所有类型支持以下设置: Setting    Description
index.cache.filter.max_size    这个是设置缓存（每次查询在一个分片里的缓存）的最大值（计数，而不是字节大小）。默认是不设置（-1），一般用于 soft 缓存或者是适合缓存的过滤器。
index.cache.filter.expire    设置缓存的数据处于非活动状态多长时间后过期。
默认值为（-1）。例如，可以设置为 5m，表示缓存的数据5分钟后过期。



##字段数据缓存

字段数据缓存的主要用在当以某一个字段排序或faceting上。
它将所有字段的数值加载到内存中为了提供快速的访问这些值。
字段数据缓存可能很昂贵为一个字段，所以建议要有足够的内存来分配它，并使它加载。

默认该缓存的类型使用 resident（常驻） (因为重建的代码太大)。 其他类型可以使用 soft。

Setting    Description
index.cache.field.max_size    这个是设置缓存（每次查询在一个分片里的缓存）的最大值（计数，而不是字节大小）。默认是不设置（-1）
index.cache.field.expire    设置缓存的数据处于非活动状态多长时间到期。
默认值为（-1）。例如，可以设置为 5m，表示缓存的数据5分钟后过期。

